% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/models.R
\docType{data}
\name{ODEs}
\alias{ODEs}
\alias{.doublewell}
\alias{doublewell}
\alias{.SIS}
\alias{SIS}
\alias{.genereg}
\alias{genereg}
\alias{.mutualistic}
\alias{mutualistic}
\title{Functions to standardize simulations of ODE/SDEs}
\format{
An object of class \code{list} of length 10.

An object of class \code{list} of length 8.

An object of class \code{list} of length 10.

An object of class \code{list} of length 15.
}
\usage{
.doublewell

doublewell(t, x, params)

.SIS

SIS(t, x, params)

.genereg

genereg(t, x, params)

.mutualistic

mutualistic(t, x, params)
}
\arguments{
\item{t}{An arbitrary time.}

\item{x}{The current state of the system. When N > 1, x is a vector with x_i representing the current state of the i'th node.}

\item{params}{A list of model parameters.}
}
\value{
A vector of derivatives
}
\description{
Paired functions and lists of parameters to standardize using deSolve's ode() to compute ground truth simulations/solutions of several ODEs on various networks.
}
\details{
Names without dots are functions which compute derivatives and are in deSolve's standard form. Each function can be used in a one-time way to compute the derivative of a system given an arbitrary time t, current state x, and parameters. More commonly, passed to deSolve's ode() or sdn's sde() as the model to be simulated.
Dot names are lists of standard model parameters. The adjacency list is also required for solutions on networks; concatenate it to the params list like `c(params, list(AL = AL))`; note that the variable name `AL` is required. If analyzing a single variable, x should have length 1 and pass AL = 0.
}
\examples{
library(parallel)
ncores <- detectCores()-1
library(igraph)
library(deSolve)
library(sdn)
g <- sample_pa(50, m = 2, directed = FALSE, start.graph = make_full_graph(3))
N <- vcount(g)
AL <- as_adj_list(g, "all") # for the case of directed networks
times <- 0:15
params <- c(.doublewell, list(AL = AL))
control <- list(times = times, ncores = ncores)
system.time(
  X <- solve_in_range(params$Ds, "D", doublewell, rep(params$xinit.low, N), params, control, "ode")
) # 4.553 seconds with 4 i3-5010U CPU @ 2.10 GHz; using the adjacency matrix takes 63 seconds
bifplot(X, params$Ds, TRUE, col = adjustcolor(1, 0.25))
}
\keyword{datasets}
