% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solvers.R
\name{enforce_absorbing_state}
\alias{enforce_absorbing_state}
\title{Handle an absorbing state in an SDE model}
\usage{
enforce_absorbing_state(x, val, which = c("floor", "ceiling"))
}
\arguments{
\item{x}{The x_i returned by the deterministic part of the model plus the stochastic part}

\item{val}{The numeric value of the absorbing state (e.g., 0)}

\item{which}{Either "floor" or "ceiling}
}
\value{
A numeric vector, the x_i
}
\description{
Require that the output of sde() respect a value which should, in an ODE, be an absorbing state. Without this enforcement, the x_i may become larger or smaller than the absorbing state due to dynamical noise. Intended to be called from within sde() by using a named list within the control list.
}
\details{
Some models have absorbing states below or above which values should not stray. In deterministic simulations, the x_i stay where they should. In stochastic simulations, dynamical noise may result in x_i outside of the prescribed boundaries. This function enforces the absorbing state. The solution used is to reset the offending values by brute force. For example, if which = "floor", this is done: ifelse(x < val, val, x).

It is not intended that this function is used on its own, but rather inside sde(). This is accomplished by means of a list with a particular name, "absorbing.state", and two named values, "value" and "which", e.g. control <- list(..., absorbing.state = list(value = 0, which = "floor")). See the examples.
}
\examples{
library(igraph)
library(sdn)

g <- make_full_graph(4)
AL <- as_adj_list(g, "all")
N <- vcount(g)
model <- SIS
params <- c(.SIS, list(AL = AL))
control <- list(
  deltaT = 0.01, times = 0:50,
  absorbing.state = list(value = 0, which = "floor")
)
X <- sde(rep(0.01, N), control$times, model, params, control)
time_ev(X, ylim = c(-0.001, 0.001))
abline(h = 0, col = 2)
min(X) # 0

X.wrong <- sde(rep(0.01, N), control$times, model, params, list(deltaT = 0.01))
min(X.wrong) # a small negative value

dev.new(width = 14)
par(mfrow = c(1, 2))
time_ev(X, main = "Right", ylim = c(-1e-4, 1e-4))
abline(h = 0, col = 2)
time_ev(X.wrong, main = "Wrong", ylim = c(-1e-4, 1e-4))
abline(h = 0, col = 2)

model <- mutualistic
params <- c(.mutualistic, list(AL = AL))
params$D <- 0.05
params$u <- -5
control$times <- 0:10
X <- sde(rep(10, N), control$times, model, params, control)
time_ev(X, ylim = c(-0.001, 0.001))

model <- genereg
params <- c(.genereg, list(AL = AL))
params$D <- 0.25
control$times <- 0:50
X <- sde(rep(10, N), control$times, model, params, control)
time_ev(X, ylim = c(-1e-4, 1e-4))
}
